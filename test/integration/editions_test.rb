require "test_helper"
require "capybara/rails"

class EditionsTest < ActionDispatch::IntegrationTest
  extend Minitest::Spec::DSL
  include Rails.application.routes.url_helpers
  include IntegrationTestHelpers

  before do
    login_as_admin
  end

  describe "#new" do
    let(:organisation) { build(:organisation) }

    before do
      Organisation.stubs(:all).returns([organisation])
    end

    describe "when a document id is provided" do
      let!(:original_edition) { create(:edition, :pension, document: document) }
      let(:document) { create(:document, :pension) }

      before do
        document.latest_edition = original_edition
        document.save!
      end

      it "initializes the form for the latest edition" do
        Document.expects(:find).with(document.id.to_s).returns(document)
        schema = stub_request_for_schema(document.block_type)
        form = stub(:form, title: "title", url: "url", back_path: "back_path", edition: original_edition, schema:, attributes: {}, form_method: :post)
        EditionForm.expects(:for).with(
          edition: original_edition,
          schema:,
        ).returns(form)

        visit new_document_edition_path(document)

        assert_text document.title
      end
    end

    describe "when a document id is not provided" do
      it "initializes the form for the latest edition" do
        edition = create(:edition, :pension)
        Edition.expects(:new).returns(edition)
        schema = stub_request_for_schema("block_type")
        form = stub(:form, title: "title", url: "url", back_path: "back_path", edition: edition, schema:, attributes: {}, form_method: :post)
        EditionForm.expects(:for).with(
          edition: edition,
          schema:,
        ).returns(form)

        visit new_edition_path(block_type: "block-type")

        assert_text "Create content block"
      end
    end
  end

  describe "#create" do
    let(:title) { "Some Title" }

    let(:document) { create(:document, :pension) }
    let!(:original_edition) { create(:edition, :pension, document: document, title:) }

    let(:document_attributes) do
      {
        block_type: "pension",
      }.with_indifferent_access
    end
    let(:details) do
      {
        "foo" => "Foo text",
        "bar" => "Bar text",
      }
    end
    let(:organisation) { build(:organisation) }

    let!(:schema) { stub_request_for_schema("pension") }

    before do
      document.latest_edition = original_edition
      document.save!
      Organisation.stubs(:all).returns([organisation])
    end

    describe "when updating an existing block" do
      it "creates a new content block with params generated by the schema" do
        assert_changes -> { document.editions.count }, from: 1, to: 2 do
          assert_changes -> { Version.count }, from: 1, to: 2 do
            post document_editions_path(document), params: {
              something: "else",
              "edition": {
                document_attributes:,
                details:,
                lead_organisation_id: organisation.id,
                title:,
              },
            }
          end
        end

        document.reload
        new_edition = document.editions.last
        new_author = EditionAuthor.last
        new_version = Version.last

        assert_equal document_attributes[:block_type], document.block_type
        assert_equal title, new_edition.title
        assert_equal details, new_edition.details

        assert_equal new_edition.document_id, document.id
        assert_equal new_edition.creator, new_author.user

        assert_equal new_version.whodunnit, new_author.user.id.to_s
      end

      it "should render the template when a validation error is raised" do
        renders_errors do
          post document_editions_path(document), params: {
            "edition": {
              document_attributes: {
                block_type: "pension",
              },
            },
          }

          assert_equal assigns(:title), document.title
        end
      end

      it "redirects to the review links step when successful" do
        redirects_to_step(:review_links) do
          post document_editions_path(document), params: {
            "edition": {
              document_attributes: {
                block_type: "pension",
              },
            },
          }
        end
      end

      describe "when subschemas are present" do
        let(:group) { nil }
        let(:subschemas) { [stub("subschema", id: "my_subschema_name", group:)] }
        let!(:schema) { stub_request_for_schema("pension", subschemas:) }

        before do
          Edition.any_instance.stubs(:has_entries_for_subschema_id?).with("my_subschema_name").returns(true)
        end

        it "redirects to the first subschema step when successful" do
          redirects_to_step(:embedded_my_subschema_name) do
            post document_editions_path(document), params: {
              "edition": {
                document_attributes: {
                  block_type: "pension",
                },
              },
            }
          end
        end

        describe "when a subschema has a group" do
          let(:group) { "group" }

          it "redirects to the group step when successful" do
            redirects_to_step(:group_group) do
              post document_editions_path(document), params: {
                "edition": {
                  document_attributes: {
                    block_type: "pension",
                  },
                },
              }
            end
          end
        end
      end
    end

    describe "when creating a new block" do
      before do
        Document.any_instance.stubs(:is_new_block?).returns(true)
      end

      it "creates a new content block with params generated by the schema" do
        post editions_path, params: {
          something: "else",
          "edition": {
            document_attributes:,
            details:,
            title:,
            lead_organisation_id: organisation.id,
          },
        }

        edition = Edition.last
        document = edition.document
        author = EditionAuthor.last
        version = Version.last

        assert_equal title, edition.title
        assert_equal document_attributes[:block_type], document.block_type
        assert_equal details, edition.details

        assert_equal edition.document_id, document.id
        assert_equal edition.creator, author.user

        assert_equal version.whodunnit, author.user.id.to_s
      end

      it "should render the template when a validation error is raised" do
        renders_errors do
          post editions_path, params: {
            something: "else",
            "edition": {
              document_attributes:,
              details:,
              organisation_id: organisation.id,
            },
          }

          assert_equal assigns(:title), "Create content block"
        end
      end

      it "redirects to the review step when successful" do
        redirects_to_step(:review) do
          post editions_path, params: {
            something: "else",
            "edition": {
              document_attributes:,
              details:,
              organisation_id: organisation.id,
            },
          }
        end
      end

      describe "when subschemas are present" do
        let(:group) { nil }
        let(:subschemas) { [stub("subschema", id: "my_subschema_name", group:)] }
        let!(:schema) { stub_request_for_schema("pension", subschemas:) }

        it "redirects to the first subschema step when successful" do
          redirects_to_step(:embedded_my_subschema_name) do
            post editions_path, params: {
              something: "else",
              "edition": {
                document_attributes:,
                details:,
                organisation_id: organisation.id,
              },
            }
          end
        end

        describe "when a subschema has a group" do
          let(:group) { "group" }

          it "redirects to the group step when successful" do
            redirects_to_step(:group_group) do
              post editions_path, params: {
                something: "else",
                "edition": {
                  document_attributes:,
                  details:,
                  organisation_id: organisation.id,
                },
              }
            end
          end
        end
      end
    end
  end

  describe "#preview" do
    let(:embed_code) { "EMBED_CODE" }
    let(:document) { build(:document) }
    let(:edition) { build_stubbed(:edition, document: document) }

    before do
      document.stubs(:embed_code).returns(embed_code)
      Edition.stubs(:find).with(edition.id.to_s).returns(edition)
      edition.stubs(:render).with(document.embed_code).returns("RENDERED_BLOCK")
      edition.stubs(:has_entries_for_multiple_subschemas?).returns(true)
    end

    it "renders a preview of the edition" do
      visit preview_edition_path(edition)

      assert_selector ".app-views-editions-preview .govspeak", text: "RENDERED_BLOCK"
    end

    it "shows a link to reorder if has_entries_for_multiple_subschemas? is true" do
      edition.stubs(:has_entries_for_multiple_subschemas?).returns(true)
      visit preview_edition_path(edition)

      assert_selector "a.govuk-link", text: "Reorder"
    end

    it "shows a link to reorder if has_entries_for_multiple_subschemas? is false" do
      edition.stubs(:has_entries_for_multiple_subschemas?).returns(false)
      visit preview_edition_path(edition)

      assert_no_selector "a.govuk-link", text: "Reorder"
    end
  end
end

def renders_errors(&block)
  edition = build(:edition, :pension, document: document)
  CreateEditionService.any_instance.expects(:call).raises(ActiveRecord::RecordInvalid, edition)
  block.call
  assert_template "editions/new"
end

def redirects_to_step(step, &block)
  edition = build(:edition, :pension, id: 123)
  CreateEditionService.any_instance.expects(:call).returns(edition)
  block.call
  assert_redirected_to workflow_path(id: edition.id, step:)
end
